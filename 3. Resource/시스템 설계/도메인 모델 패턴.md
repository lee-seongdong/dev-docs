# 도메인 모델 패턴 (Domain Model Pattern)
DDD(Domain-Driven Design)에서 사용되는 핵심 패턴으로,  
비즈니스 도메인을 중심으로 설계하며, 각 도메인 객체가 자신의 비즈니스 로직을 포함하는 패턴  

## 1. 특징
- 풍부한 도메인 모델: Entity가 데이터와 비즈니스 로직을 모두 포함 (Rich Domain Model)
- 객체지향적: 데이터와 행위가 함께 있어 정보 은닉과 캡슐화가 잘 구현됨
- 높은 재사용성: 비즈니스 로직이 도메인 객체에 캡슐화되어 재사용 가능

### 1.1. 장점
- 높은 응집도: 관련된 데이터와 로직이 한 곳에 모여 있음
- 재사용성: 비즈니스 로직이 도메인 객체에 캡슐화되어 재사용 가능
- 테스트 용이성: 도메인 로직을 독립적으로 테스트 가능
- 유지보수성: 비즈니스 규칙 변경 시 도메인 객체만 수정
- 확장성: 복잡한 비즈니스 로직에 대응 가능
- 객체지향적: OOP 원칙을 잘 따름

### 1.2. 단점
- 높은 학습 곡선: 도메인 모델링 능력 필요
- 초기 설계 비용: 도메인 분석과 모델링에 시간 투자 필요
- 과도한 설계: 단순한 CRUD에는 오버엔지니어링
- ORM 매핑 복잡도: Rich Domain Model과 DB 매핑이 복잡할 수 있음

### 1.3. 적합한 사용 사례
- 복잡한 비즈니스 규칙: 도메인 로직이 복잡하고 자주 변경되는 경우
- 대규모 엔터프라이즈 시스템: 장기 유지보수가 필요한 시스템
- 도메인 전문가와 협업: 비즈니스 지식이 중요한 프로젝트


## 2. 핵심 원칙
- Tell, Don't Ask: 데이터를 꺼내서 처리하지 말고, 객체에게 행위를 요청
- 정보 은닉: 내부 상태를 숨기고 행위를 통해서만 상태 변경 (단순 setter, getter는 지양)
- 단일 책임: 각 도메인 객체는 명확한 책임을 가짐
- 불변성: Value Object는 불변으로 설계
- 유비쿼터스 언어: 도메인 전문가와 개발자가 같은 용어 사용


## 3. 패키지 구조

```
src/main/java/com/example/order/
│
├── controller/
│   └── OrderController.java          # API 엔드포인트
│
├── application/
│   └── OrderService.java              # 애플리케이션 서비스 (조율 역할)
│
├── domain/
│   ├── model/
│   │   ├── Order.java                 # 주문 Aggregate Root (비즈니스 로직 포함)
│   │   ├── OrderItem.java             # 주문 항목 Entity
│   │   ├── Customer.java              # 고객 Aggregate Root
│   │   ├── Product.java               # 상품 Aggregate Root
│   │   └── Money.java                 # Value Object (금액)
│   │
│   ├── service/
│   │   └── DiscountPolicy.java        # 도메인 서비스
│   │
│   └── repository/
│       ├── OrderRepository.java       # Repository Interface
│       ├── CustomerRepository.java
│       └── ProductRepository.java
│
├── infrastructure/
│   └── repository/
│       ├── OrderRepositoryImpl.java   # Repository 구현
│       ├── CustomerRepositoryImpl.java
│       └── ProductRepositoryImpl.java
│
└── dto/
    ├── CreateOrderRequest.java        # 요청 DTO
    └── OrderResponse.java             # 응답 DTO
```

## 4. 코드 예시

### Value Object
```java
// Money.java - 금액을 표현하는 Value Object
public class Money {
    private final BigDecimal amount;
    
    public Money(BigDecimal amount) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("금액은 0 이상이어야 합니다.");
        }
        this.amount = amount;
    }
    
    public Money add(Money other) {
        return new Money(this.amount.add(other.amount));
    }
    
    public Money multiply(int quantity) {
        return new Money(this.amount.multiply(BigDecimal.valueOf(quantity)));
    }
    
    public Money applyDiscount(double rate) {
        return new Money(this.amount.multiply(BigDecimal.valueOf(1 - rate)));
    }
    
    public boolean isGreaterThan(Money other) {
        return this.amount.compareTo(other.amount) > 0;
    }
    
    public BigDecimal getAmount() {
        return amount;
    }
}
```

### Domain Entity (풍부한 도메인 모델)
```java
// Order.java - 비즈니스 로직을 포함하는 Aggregate Root
@Entity
@Table(name = "orders")
public class Order {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Embedded
    private CustomerId customerId;
    
    private LocalDateTime orderDate;
    
    @Enumerated(EnumType.STRING)
    private OrderStatus status;
    
    @Embedded
    @AttributeOverride(name = "amount", column = @Column(name = "total_amount"))
    private Money totalAmount;
    
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "order_id")
    private List<OrderItem> orderItems = new ArrayList<>();
    
    protected Order() {} // JPA용
    
    // 정적 팩토리 메서드
    public static Order create(CustomerId customerId, List<OrderItem> items) {
        Order order = new Order();
        order.customerId = customerId;
        order.orderDate = LocalDateTime.now();
        order.status = OrderStatus.PENDING;
        order.orderItems = new ArrayList<>(items);
        order.calculateTotalAmount();
        return order;
    }
    
    // 비즈니스 로직: 주문 항목 추가
    public void addItem(OrderItem item) {
        if (this.status != OrderStatus.PENDING) {
            throw new IllegalStateException("대기 중인 주문만 항목을 추가할 수 있습니다.");
        }
        this.orderItems.add(item);
        calculateTotalAmount();
    }
    
    // 비즈니스 로직: 총액 계산
    private void calculateTotalAmount() {
        this.totalAmount = orderItems.stream()
            .map(OrderItem::getSubtotal)
            .reduce(Money.ZERO, Money::add);
    }
    
    // 비즈니스 로직: 할인 적용
    public void applyDiscount(DiscountPolicy discountPolicy) {
        Money discountedAmount = discountPolicy.calculate(this.totalAmount, this.customerId);
        this.totalAmount = discountedAmount;
    }
    
    // 비즈니스 로직: 최소 주문 금액 검증
    public void validateMinimumAmount(Money minimumAmount) {
        if (!this.totalAmount.isGreaterThan(minimumAmount)) {
            throw new IllegalStateException(
                "최소 주문 금액은 " + minimumAmount.getAmount() + "원입니다."
            );
        }
    }
    
    // 비즈니스 로직: 주문 승인
    public void approve() {
        if (this.status != OrderStatus.PENDING) {
            throw new IllegalStateException("대기 중인 주문만 승인할 수 있습니다.");
        }
        this.status = OrderStatus.APPROVED;
    }
    
    // 비즈니스 로직: 주문 취소
    public void cancel() {
        if (this.status == OrderStatus.SHIPPED || this.status == OrderStatus.DELIVERED) {
            throw new IllegalStateException("배송 중이거나 배송 완료된 주문은 취소할 수 없습니다.");
        }
        this.status = OrderStatus.CANCELLED;
    }
    
    // 비즈니스 로직: 배송 시작
    public void ship() {
        if (this.status != OrderStatus.APPROVED) {
            throw new IllegalStateException("승인된 주문만 배송할 수 있습니다.");
        }
        this.status = OrderStatus.SHIPPED;
    }
    
    // 비즈니스 규칙: 취소 가능 여부
    public boolean isCancellable() {
        return this.status == OrderStatus.PENDING || 
               this.status == OrderStatus.APPROVED;
    }
    
    // Getter
    public List<OrderItem> getOrderItems() {
        return Collections.unmodifiableList(orderItems);
    }
    
    public OrderStatus getStatus() {
        return status;
    }
    
    public Money getTotalAmount() {
        return totalAmount;
    }
}
```

```java
// OrderItem.java - Entity
@Entity
public class OrderItem {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Embedded
    private ProductId productId;
    
    private int quantity;
    
    @Embedded
    @AttributeOverride(name = "amount", column = @Column(name = "price"))
    private Money price;
    
    protected OrderItem() {} // JPA용
    
    public OrderItem(ProductId productId, int quantity, Money price) {
        if (quantity <= 0) {
            throw new IllegalArgumentException("수량은 1 이상이어야 합니다.");
        }
        this.productId = productId;
        this.quantity = quantity;
        this.price = price;
    }
    
    // 비즈니스 로직: 소계 계산
    public Money getSubtotal() {
        return price.multiply(quantity);
    }
    
    public ProductId getProductId() {
        return productId;
    }
    
    public int getQuantity() {
        return quantity;
    }
}
```

```java
// Product.java - Aggregate Root
@Entity
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    @Embedded
    @AttributeOverride(name = "amount", column = @Column(name = "price"))
    private Money price;
    
    private int stock;
    
    protected Product() {}
    
    public Product(String name, Money price, int stock) {
        this.name = name;
        this.price = price;
        this.stock = stock;
    }
    
    // 비즈니스 로직: 재고 확인
    public boolean isStockAvailable(int quantity) {
        return this.stock >= quantity;
    }
    
    // 비즈니스 로직: 재고 차감
    public void decreaseStock(int quantity) {
        if (!isStockAvailable(quantity)) {
            throw new IllegalStateException("재고가 부족합니다: " + this.name);
        }
        this.stock -= quantity;
    }
    
    // 비즈니스 로직: 재고 복구
    public void increaseStock(int quantity) {
        this.stock += quantity;
    }
    
    public Money getPrice() {
        return price;
    }
    
    public String getName() {
        return name;
    }
}
```

```java
// Customer.java - Aggregate Root
@Entity
public class Customer {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    @Enumerated(EnumType.STRING)
    private CustomerGrade grade;
    
    @Enumerated(EnumType.STRING)
    private CustomerStatus status;
    
    protected Customer() {}
    
    // 비즈니스 규칙: 주문 가능 여부
    public boolean canOrder() {
        return this.status == CustomerStatus.ACTIVE;
    }
    
    // 비즈니스 규칙: 할인율
    public double getDiscountRate() {
        return switch (this.grade) {
            case VIP -> 0.1;
            case GOLD -> 0.05;
            case SILVER -> 0.02;
            default -> 0.0;
        };
    }
    
    public CustomerGrade getGrade() {
        return grade;
    }
    
    public CustomerStatus getStatus() {
        return status;
    }
}
```

### Domain Service
```java
// DiscountPolicy.java - 도메인 서비스
@Component
public class DiscountPolicy {
    
    private final CustomerRepository customerRepository;
    
    public DiscountPolicy(CustomerRepository customerRepository) {
        this.customerRepository = customerRepository;
    }
    
    // 여러 도메인 객체를 조율하는 비즈니스 로직
    public Money calculate(Money originalAmount, CustomerId customerId) {
        Customer customer = customerRepository.findById(customerId)
            .orElseThrow(() -> new IllegalArgumentException("고객을 찾을 수 없습니다."));
        
        double discountRate = customer.getDiscountRate();
        return originalAmount.applyDiscount(discountRate);
    }
}
```

### Application Service (조율자)
```java
// OrderService.java - 도메인 객체들을 조율하는 얇은 서비스 레이어
@Service
@RequiredArgsConstructor
public class OrderService {
    
    private final OrderRepository orderRepository;
    private final ProductRepository productRepository;
    private final CustomerRepository customerRepository;
    private final DiscountPolicy discountPolicy;
    
    private static final Money MINIMUM_ORDER_AMOUNT = new Money(BigDecimal.valueOf(10000));
    
    @Transactional
    public OrderResponse createOrder(CreateOrderRequest request) {
        // 1. 고객 조회 및 검증
        Customer customer = customerRepository.findById(request.getCustomerId())
            .orElseThrow(() -> new IllegalArgumentException("고객을 찾을 수 없습니다."));
        
        if (!customer.canOrder()) {
            throw new IllegalStateException("주문할 수 없는 고객 상태입니다.");
        }
        
        // 2. 주문 항목 생성 및 재고 차감
        List<OrderItem> orderItems = new ArrayList<>();
        for (OrderItemRequest itemRequest : request.getItems()) {
            Product product = productRepository.findById(itemRequest.getProductId())
                .orElseThrow(() -> new IllegalArgumentException("상품을 찾을 수 없습니다."));
            
            // 도메인 객체가 자신의 비즈니스 로직 수행
            product.decreaseStock(itemRequest.getQuantity());
            productRepository.save(product);
            
            OrderItem orderItem = new OrderItem(
                new ProductId(product.getId()),
                itemRequest.getQuantity(),
                product.getPrice()
            );
            orderItems.add(orderItem);
        }
        
        // 3. 주문 생성 (도메인 객체가 총액 계산)
        Order order = Order.create(new CustomerId(customer.getId()), orderItems);
        
        // 4. 할인 적용 (도메인 서비스 활용)
        order.applyDiscount(discountPolicy);
        
        // 5. 비즈니스 규칙 검증 (도메인 객체가 수행)
        order.validateMinimumAmount(MINIMUM_ORDER_AMOUNT);
        
        // 6. 주문 저장
        Order savedOrder = orderRepository.save(order);
        
        return new OrderResponse(savedOrder);
    }
    
    @Transactional
    public void cancelOrder(Long orderId) {
        // 1. 주문 조회
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new IllegalArgumentException("주문을 찾을 수 없습니다."));
        
        // 2. 도메인 객체가 비즈니스 규칙 검증 및 취소 처리
        order.cancel();
        
        // 3. 재고 복구
        for (OrderItem item : order.getOrderItems()) {
            Product product = productRepository.findById(item.getProductId().getValue())
                .orElseThrow(() -> new IllegalArgumentException("상품을 찾을 수 없습니다."));
            
            product.increaseStock(item.getQuantity());
            productRepository.save(product);
        }
        
        orderRepository.save(order);
    }
}
```

