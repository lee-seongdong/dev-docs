# 도메인 모델 패턴 (Domain Model Pattern)

## 개요
도메인 모델 패턴은 비즈니스 도메인을 중심으로 설계하며, 각 도메인 객체가 자신의 비즈니스 로직을 포함하는 패턴입니다.
DDD(Domain-Driven Design)에서 사용되는 핵심 패턴으로, 객체지향 원칙을 충실히 따릅니다.

## 특징
- **풍부한 도메인 모델**: Entity가 데이터와 비즈니스 로직을 모두 포함 (Rich Domain Model)
- **캡슐화**: 데이터와 행위가 함께 있어 정보 은닉과 캡슐화가 잘 구현됨
- **높은 재사용성**: 비즈니스 로직이 도메인 객체에 캡슐화되어 재사용 가능
- **객체지향적**: 상속, 다형성, 캡슐화 등 OOP 원칙을 잘 활용

## 패키지 구조

```
src/main/java/com/example/order/
│
├── controller/
│   └── OrderController.java          # API 엔드포인트
│
├── application/
│   └── OrderService.java              # 애플리케이션 서비스 (조율 역할)
│
├── domain/
│   ├── model/
│   │   ├── Order.java                 # 주문 Aggregate Root (비즈니스 로직 포함)
│   │   ├── OrderItem.java             # 주문 항목 Entity
│   │   ├── Customer.java              # 고객 Aggregate Root
│   │   ├── Product.java               # 상품 Aggregate Root
│   │   └── Money.java                 # Value Object (금액)
│   │
│   ├── service/
│   │   └── DiscountPolicy.java        # 도메인 서비스
│   │
│   └── repository/
│       ├── OrderRepository.java       # Repository Interface
│       ├── CustomerRepository.java
│       └── ProductRepository.java
│
├── infrastructure/
│   └── repository/
│       ├── OrderRepositoryImpl.java   # Repository 구현
│       ├── CustomerRepositoryImpl.java
│       └── ProductRepositoryImpl.java
│
└── dto/
    ├── CreateOrderRequest.java        # 요청 DTO
    └── OrderResponse.java             # 응답 DTO
```

## 코드 예시

### Value Object
```java
// Money.java - 금액을 표현하는 Value Object
public class Money {
    private final BigDecimal amount;
    
    public Money(BigDecimal amount) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("금액은 0 이상이어야 합니다.");
        }
        this.amount = amount;
    }
    
    public Money add(Money other) {
        return new Money(this.amount.add(other.amount));
    }
    
    public Money multiply(int quantity) {
        return new Money(this.amount.multiply(BigDecimal.valueOf(quantity)));
    }
    
    public Money applyDiscount(double rate) {
        return new Money(this.amount.multiply(BigDecimal.valueOf(1 - rate)));
    }
    
    public boolean isGreaterThan(Money other) {
        return this.amount.compareTo(other.amount) > 0;
    }
    
    public BigDecimal getAmount() {
        return amount;
    }
}
```

### Domain Entity (풍부한 도메인 모델)
```java
// Order.java - 비즈니스 로직을 포함하는 Aggregate Root
@Entity
@Table(name = "orders")
public class Order {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Embedded
    private CustomerId customerId;
    
    private LocalDateTime orderDate;
    
    @Enumerated(EnumType.STRING)
    private OrderStatus status;
    
    @Embedded
    @AttributeOverride(name = "amount", column = @Column(name = "total_amount"))
    private Money totalAmount;
    
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "order_id")
    private List<OrderItem> orderItems = new ArrayList<>();
    
    protected Order() {} // JPA용
    
    // 정적 팩토리 메서드
    public static Order create(CustomerId customerId, List<OrderItem> items) {
        Order order = new Order();
        order.customerId = customerId;
        order.orderDate = LocalDateTime.now();
        order.status = OrderStatus.PENDING;
        order.orderItems = new ArrayList<>(items);
        order.calculateTotalAmount();
        return order;
    }
    
    // 비즈니스 로직: 주문 항목 추가
    public void addItem(OrderItem item) {
        if (this.status != OrderStatus.PENDING) {
            throw new IllegalStateException("대기 중인 주문만 항목을 추가할 수 있습니다.");
        }
        this.orderItems.add(item);
        calculateTotalAmount();
    }
    
    // 비즈니스 로직: 총액 계산
    private void calculateTotalAmount() {
        this.totalAmount = orderItems.stream()
            .map(OrderItem::getSubtotal)
            .reduce(Money.ZERO, Money::add);
    }
    
    // 비즈니스 로직: 할인 적용
    public void applyDiscount(DiscountPolicy discountPolicy) {
        Money discountedAmount = discountPolicy.calculate(this.totalAmount, this.customerId);
        this.totalAmount = discountedAmount;
    }
    
    // 비즈니스 로직: 최소 주문 금액 검증
    public void validateMinimumAmount(Money minimumAmount) {
        if (!this.totalAmount.isGreaterThan(minimumAmount)) {
            throw new IllegalStateException(
                "최소 주문 금액은 " + minimumAmount.getAmount() + "원입니다."
            );
        }
    }
    
    // 비즈니스 로직: 주문 승인
    public void approve() {
        if (this.status != OrderStatus.PENDING) {
            throw new IllegalStateException("대기 중인 주문만 승인할 수 있습니다.");
        }
        this.status = OrderStatus.APPROVED;
    }
    
    // 비즈니스 로직: 주문 취소
    public void cancel() {
        if (this.status == OrderStatus.SHIPPED || this.status == OrderStatus.DELIVERED) {
            throw new IllegalStateException("배송 중이거나 배송 완료된 주문은 취소할 수 없습니다.");
        }
        this.status = OrderStatus.CANCELLED;
    }
    
    // 비즈니스 로직: 배송 시작
    public void ship() {
        if (this.status != OrderStatus.APPROVED) {
            throw new IllegalStateException("승인된 주문만 배송할 수 있습니다.");
        }
        this.status = OrderStatus.SHIPPED;
    }
    
    // 비즈니스 규칙: 취소 가능 여부
    public boolean isCancellable() {
        return this.status == OrderStatus.PENDING || 
               this.status == OrderStatus.APPROVED;
    }
    
    // Getter
    public List<OrderItem> getOrderItems() {
        return Collections.unmodifiableList(orderItems);
    }
    
    public OrderStatus getStatus() {
        return status;
    }
    
    public Money getTotalAmount() {
        return totalAmount;
    }
}
```

```java
// OrderItem.java - Entity
@Entity
public class OrderItem {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Embedded
    private ProductId productId;
    
    private int quantity;
    
    @Embedded
    @AttributeOverride(name = "amount", column = @Column(name = "price"))
    private Money price;
    
    protected OrderItem() {} // JPA용
    
    public OrderItem(ProductId productId, int quantity, Money price) {
        if (quantity <= 0) {
            throw new IllegalArgumentException("수량은 1 이상이어야 합니다.");
        }
        this.productId = productId;
        this.quantity = quantity;
        this.price = price;
    }
    
    // 비즈니스 로직: 소계 계산
    public Money getSubtotal() {
        return price.multiply(quantity);
    }
    
    public ProductId getProductId() {
        return productId;
    }
    
    public int getQuantity() {
        return quantity;
    }
}
```

```java
// Product.java - Aggregate Root
@Entity
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    @Embedded
    @AttributeOverride(name = "amount", column = @Column(name = "price"))
    private Money price;
    
    private int stock;
    
    protected Product() {}
    
    public Product(String name, Money price, int stock) {
        this.name = name;
        this.price = price;
        this.stock = stock;
    }
    
    // 비즈니스 로직: 재고 확인
    public boolean isStockAvailable(int quantity) {
        return this.stock >= quantity;
    }
    
    // 비즈니스 로직: 재고 차감
    public void decreaseStock(int quantity) {
        if (!isStockAvailable(quantity)) {
            throw new IllegalStateException("재고가 부족합니다: " + this.name);
        }
        this.stock -= quantity;
    }
    
    // 비즈니스 로직: 재고 복구
    public void increaseStock(int quantity) {
        this.stock += quantity;
    }
    
    public Money getPrice() {
        return price;
    }
    
    public String getName() {
        return name;
    }
}
```

```java
// Customer.java - Aggregate Root
@Entity
public class Customer {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    @Enumerated(EnumType.STRING)
    private CustomerGrade grade;
    
    @Enumerated(EnumType.STRING)
    private CustomerStatus status;
    
    protected Customer() {}
    
    // 비즈니스 규칙: 주문 가능 여부
    public boolean canOrder() {
        return this.status == CustomerStatus.ACTIVE;
    }
    
    // 비즈니스 규칙: 할인율
    public double getDiscountRate() {
        return switch (this.grade) {
            case VIP -> 0.1;
            case GOLD -> 0.05;
            case SILVER -> 0.02;
            default -> 0.0;
        };
    }
    
    public CustomerGrade getGrade() {
        return grade;
    }
    
    public CustomerStatus getStatus() {
        return status;
    }
}
```

### Domain Service
```java
// DiscountPolicy.java - 도메인 서비스
@Component
public class DiscountPolicy {
    
    private final CustomerRepository customerRepository;
    
    public DiscountPolicy(CustomerRepository customerRepository) {
        this.customerRepository = customerRepository;
    }
    
    // 여러 도메인 객체를 조율하는 비즈니스 로직
    public Money calculate(Money originalAmount, CustomerId customerId) {
        Customer customer = customerRepository.findById(customerId)
            .orElseThrow(() -> new IllegalArgumentException("고객을 찾을 수 없습니다."));
        
        double discountRate = customer.getDiscountRate();
        return originalAmount.applyDiscount(discountRate);
    }
}
```

### Application Service (조율자)
```java
// OrderService.java - 도메인 객체들을 조율하는 얇은 서비스 레이어
@Service
@RequiredArgsConstructor
public class OrderService {
    
    private final OrderRepository orderRepository;
    private final ProductRepository productRepository;
    private final CustomerRepository customerRepository;
    private final DiscountPolicy discountPolicy;
    
    private static final Money MINIMUM_ORDER_AMOUNT = new Money(BigDecimal.valueOf(10000));
    
    @Transactional
    public OrderResponse createOrder(CreateOrderRequest request) {
        // 1. 고객 조회 및 검증
        Customer customer = customerRepository.findById(request.getCustomerId())
            .orElseThrow(() -> new IllegalArgumentException("고객을 찾을 수 없습니다."));
        
        if (!customer.canOrder()) {
            throw new IllegalStateException("주문할 수 없는 고객 상태입니다.");
        }
        
        // 2. 주문 항목 생성 및 재고 차감
        List<OrderItem> orderItems = new ArrayList<>();
        for (OrderItemRequest itemRequest : request.getItems()) {
            Product product = productRepository.findById(itemRequest.getProductId())
                .orElseThrow(() -> new IllegalArgumentException("상품을 찾을 수 없습니다."));
            
            // 도메인 객체가 자신의 비즈니스 로직 수행
            product.decreaseStock(itemRequest.getQuantity());
            productRepository.save(product);
            
            OrderItem orderItem = new OrderItem(
                new ProductId(product.getId()),
                itemRequest.getQuantity(),
                product.getPrice()
            );
            orderItems.add(orderItem);
        }
        
        // 3. 주문 생성 (도메인 객체가 총액 계산)
        Order order = Order.create(new CustomerId(customer.getId()), orderItems);
        
        // 4. 할인 적용 (도메인 서비스 활용)
        order.applyDiscount(discountPolicy);
        
        // 5. 비즈니스 규칙 검증 (도메인 객체가 수행)
        order.validateMinimumAmount(MINIMUM_ORDER_AMOUNT);
        
        // 6. 주문 저장
        Order savedOrder = orderRepository.save(order);
        
        return new OrderResponse(savedOrder);
    }
    
    @Transactional
    public void cancelOrder(Long orderId) {
        // 1. 주문 조회
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new IllegalArgumentException("주문을 찾을 수 없습니다."));
        
        // 2. 도메인 객체가 비즈니스 규칙 검증 및 취소 처리
        order.cancel();
        
        // 3. 재고 복구
        for (OrderItem item : order.getOrderItems()) {
            Product product = productRepository.findById(item.getProductId().getValue())
                .orElseThrow(() -> new IllegalArgumentException("상품을 찾을 수 없습니다."));
            
            product.increaseStock(item.getQuantity());
            productRepository.save(product);
        }
        
        orderRepository.save(order);
    }
}
```

## 시퀀스 다이어그램

```
[주문 생성 흐름]

Controller -> Service: createOrder(request)
Service -> CustomerRepository: findById(customerId)
CustomerRepository --> Service: Customer
Service -> Customer: canOrder() - 비즈니스 규칙 검증
Customer --> Service: true

loop 각 주문 항목
    Service -> ProductRepository: findById(productId)
    ProductRepository --> Service: Product
    Service -> Product: decreaseStock(quantity) - 비즈니스 로직
    Product -> Product: isStockAvailable() - 내부 검증
    Service -> OrderItem: new OrderItem(productId, quantity, price)
    OrderItem -> OrderItem: validate() - 생성자에서 검증
end

Service -> Order: create(customerId, orderItems)
Order -> Order: calculateTotalAmount() - 비즈니스 로직

Service -> DiscountPolicy: calculate(amount, customerId)
DiscountPolicy -> CustomerRepository: findById(customerId)
DiscountPolicy -> Customer: getDiscountRate() - 비즈니스 로직
DiscountPolicy --> Service: discountedAmount

Service -> Order: applyDiscount(discountPolicy)
Service -> Order: validateMinimumAmount(minimum)
Order -> Order: 비즈니스 규칙 검증

Service -> OrderRepository: save(order)
OrderRepository --> Service: Order
Service --> Controller: OrderResponse
```

## 클래스 다이어그램

```
┌─────────────────────┐
│   OrderController   │
└──────────┬──────────┘
           │ 의존
           ↓
┌─────────────────────┐
│   OrderService      │
│  (Application)      │
│                     │
│ 얇은 조율 레이어    │
│ - 트랜잭션 관리     │
│ - 도메인 객체 조율  │
└──────────┬──────────┘
           │ 사용
           ↓
┌──────────────────────────────────────┐
│         Domain Layer                 │
├──────────────────────────────────────┤
│                                      │
│  ┌────────────────────────────┐     │
│  │  Order (Aggregate Root)    │     │
│  │  ───────────────────────   │     │
│  │  - customerId              │     │
│  │  - orderItems              │     │
│  │  - totalAmount             │     │
│  │  - status                  │     │
│  │  ───────────────────────   │     │
│  │  + create()                │     │
│  │  + addItem()               │     │
│  │  + cancel()                │     │
│  │  + applyDiscount()         │◄────┼─── 비즈니스 로직 포함
│  │  + validateMinimumAmount() │     │
│  └────────────┬───────────────┘     │
│               │ 포함                 │
│               ↓                      │
│  ┌────────────────────────────┐     │
│  │  OrderItem (Entity)        │     │
│  │  ───────────────────────   │     │
│  │  - productId               │     │
│  │  - quantity                │     │
│  │  - price                   │     │
│  │  ───────────────────────   │     │
│  │  + getSubtotal()           │◄────┼─── 비즈니스 로직
│  └────────────────────────────┘     │
│                                      │
│  ┌────────────────────────────┐     │
│  │  Money (Value Object)      │     │
│  │  ───────────────────────   │     │
│  │  - amount                  │     │
│  │  ───────────────────────   │     │
│  │  + add()                   │     │
│  │  + multiply()              │     │
│  │  + applyDiscount()         │◄────┼─── 불변 객체
│  └────────────────────────────┘     │
│                                      │
│  ┌────────────────────────────┐     │
│  │  DiscountPolicy            │     │
│  │  (Domain Service)          │     │
│  │  ───────────────────────   │     │
│  │  + calculate()             │◄────┼─── 도메인 서비스
│  └────────────────────────────┘     │
│                                      │
└──────────────────────────────────────┘
```

## 장점
1. **높은 응집도**: 관련된 데이터와 로직이 한 곳에 모여 있음
2. **재사용성**: 비즈니스 로직이 도메인 객체에 캡슐화되어 재사용 가능
3. **테스트 용이성**: 도메인 로직을 독립적으로 테스트 가능
4. **유지보수성**: 비즈니스 규칙 변경 시 도메인 객체만 수정
5. **확장성**: 복잡한 비즈니스 로직에 대응 가능
6. **객체지향적**: OOP 원칙을 잘 따름

## 단점
1. **높은 학습 곡선**: 도메인 모델링 능력 필요
2. **초기 설계 비용**: 도메인 분석과 모델링에 시간 투자 필요
3. **과도한 설계**: 단순한 CRUD에는 오버엔지니어링
4. **ORM 매핑 복잡도**: Rich Domain Model과 DB 매핑이 복잡할 수 있음

## 적합한 사용 사례
- **복잡한 비즈니스 규칙**: 도메인 로직이 복잡하고 자주 변경되는 경우
- **대규모 엔터프라이즈 시스템**: 장기 유지보수가 필요한 시스템
- **DDD 적용**: 전략적 설계와 전술적 설계가 모두 필요한 경우
- **도메인 전문가와 협업**: 비즈니스 지식이 중요한 프로젝트

## 핵심 원칙
1. **Tell, Don't Ask**: 데이터를 꺼내서 처리하지 말고, 객체에게 행위를 요청
2. **정보 은닉**: 내부 상태를 숨기고 행위를 통해서만 상태 변경
3. **단일 책임**: 각 도메인 객체는 명확한 책임을 가짐
4. **불변성**: Value Object는 불변으로 설계
5. **유비쿼터스 언어**: 도메인 전문가와 개발자가 같은 용어 사용
