# 트랜잭션 스크립트 패턴 (Transaction Script Pattern)

## 개요
트랜잭션 스크립트 패턴은 각 비즈니스 트랜잭션을 하나의 프로시저(메서드)로 구현하는 패턴입니다.
서비스 계층에서 절차적으로 비즈니스 로직을 구현하며, 도메인 객체는 주로 데이터 전달 용도로만 사용됩니다.

## 특징
- **절차적 프로그래밍**: 비즈니스 로직이 서비스 레이어의 메서드에 순차적으로 작성됨
- **빈약한 도메인 모델**: Entity는 getter/setter만 가진 데이터 객체 (Anemic Domain Model)
- **단순한 구조**: 이해하기 쉽고 작은 프로젝트에 적합
- **낮은 재사용성**: 비즈니스 로직이 분산되어 있어 재사용이 어려움

## 패키지 구조

```
src/main/java/com/example/order/
│
├── controller/
│   └── OrderController.java          # API 엔드포인트
│
├── service/
│   └── OrderService.java              # 비즈니스 로직 (트랜잭션 스크립트)
│
├── repository/
│   ├── OrderRepository.java           # 주문 데이터 접근
│   ├── ProductRepository.java         # 상품 데이터 접근
│   └── CustomerRepository.java        # 고객 데이터 접근
│
├── entity/
│   ├── Order.java                     # 주문 엔티티 (데이터만)
│   ├── OrderItem.java                 # 주문 항목 엔티티
│   ├── Product.java                   # 상품 엔티티
│   └── Customer.java                  # 고객 엔티티
│
└── dto/
    ├── CreateOrderRequest.java        # 주문 생성 요청 DTO
    └── OrderResponse.java             # 주문 응답 DTO
```

## 코드 예시

### Entity (빈약한 도메인 모델)
```java
// Order.java - 비즈니스 로직 없이 데이터만 저장
@Entity
@Table(name = "orders")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private Long customerId;
    private LocalDateTime orderDate;
    private String status;
    private BigDecimal totalAmount;
    
    @OneToMany(cascade = CascadeType.ALL)
    private List<OrderItem> orderItems = new ArrayList<>();
    
    // getter, setter만 존재
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public Long getCustomerId() { return customerId; }
    public void setCustomerId(Long customerId) { this.customerId = customerId; }
    // ... 나머지 getter/setter
}
```

```java
// OrderItem.java
@Entity
public class OrderItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private Long productId;
    private Integer quantity;
    private BigDecimal price;
    
    // getter, setter만 존재
}
```

### Service (모든 비즈니스 로직 포함)
```java
// OrderService.java - 모든 비즈니스 로직이 여기에 집중됨
@Service
@RequiredArgsConstructor
public class OrderService {
    
    private final OrderRepository orderRepository;
    private final ProductRepository productRepository;
    private final CustomerRepository customerRepository;
    
    @Transactional
    public OrderResponse createOrder(CreateOrderRequest request) {
        // 1. 고객 검증
        Customer customer = customerRepository.findById(request.getCustomerId())
            .orElseThrow(() -> new IllegalArgumentException("고객을 찾을 수 없습니다."));
        
        if (customer.getStatus().equals("SUSPENDED")) {
            throw new IllegalStateException("정지된 고객은 주문할 수 없습니다.");
        }
        
        // 2. 주문 생성
        Order order = new Order();
        order.setCustomerId(customer.getId());
        order.setOrderDate(LocalDateTime.now());
        order.setStatus("PENDING");
        
        // 3. 주문 항목 처리
        BigDecimal totalAmount = BigDecimal.ZERO;
        
        for (OrderItemRequest itemRequest : request.getItems()) {
            // 3-1. 상품 조회 및 검증
            Product product = productRepository.findById(itemRequest.getProductId())
                .orElseThrow(() -> new IllegalArgumentException("상품을 찾을 수 없습니다."));
            
            // 3-2. 재고 확인
            if (product.getStock() < itemRequest.getQuantity()) {
                throw new IllegalStateException("재고가 부족합니다: " + product.getName());
            }
            
            // 3-3. 주문 항목 생성
            OrderItem orderItem = new OrderItem();
            orderItem.setProductId(product.getId());
            orderItem.setQuantity(itemRequest.getQuantity());
            orderItem.setPrice(product.getPrice());
            
            order.getOrderItems().add(orderItem);
            
            // 3-4. 재고 차감
            product.setStock(product.getStock() - itemRequest.getQuantity());
            productRepository.save(product);
            
            // 3-5. 금액 계산
            BigDecimal itemTotal = product.getPrice()
                .multiply(BigDecimal.valueOf(itemRequest.getQuantity()));
            totalAmount = totalAmount.add(itemTotal);
        }
        
        // 4. 할인 적용 (VIP 고객 10% 할인)
        if (customer.getGrade().equals("VIP")) {
            totalAmount = totalAmount.multiply(BigDecimal.valueOf(0.9));
        }
        
        // 5. 최소 주문 금액 검증
        if (totalAmount.compareTo(BigDecimal.valueOf(10000)) < 0) {
            throw new IllegalStateException("최소 주문 금액은 10,000원입니다.");
        }
        
        // 6. 주문 저장
        order.setTotalAmount(totalAmount);
        Order savedOrder = orderRepository.save(order);
        
        // 7. 응답 생성
        return new OrderResponse(savedOrder);
    }
    
    @Transactional
    public void cancelOrder(Long orderId) {
        // 1. 주문 조회
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new IllegalArgumentException("주문을 찾을 수 없습니다."));
        
        // 2. 취소 가능 상태 확인
        if (!order.getStatus().equals("PENDING")) {
            throw new IllegalStateException("취소할 수 없는 주문 상태입니다.");
        }
        
        // 3. 재고 복구
        for (OrderItem item : order.getOrderItems()) {
            Product product = productRepository.findById(item.getProductId())
                .orElseThrow(() -> new IllegalArgumentException("상품을 찾을 수 없습니다."));
            
            product.setStock(product.getStock() + item.getQuantity());
            productRepository.save(product);
        }
        
        // 4. 주문 상태 변경
        order.setStatus("CANCELLED");
        orderRepository.save(order);
    }
}
```

## 시퀀스 다이어그램

```
[주문 생성 흐름]

Controller -> Service: createOrder(request)
Service -> CustomerRepository: findById(customerId)
CustomerRepository --> Service: Customer
Service -> Service: 고객 상태 검증
Service -> Service: Order 객체 생성 (new Order())
loop 각 주문 항목
    Service -> ProductRepository: findById(productId)
    ProductRepository --> Service: Product
    Service -> Service: 재고 확인
    Service -> Service: OrderItem 생성 및 추가
    Service -> ProductRepository: save(product) - 재고 차감
    Service -> Service: 금액 계산
end
Service -> Service: 할인 적용
Service -> Service: 최소 금액 검증
Service -> OrderRepository: save(order)
OrderRepository --> Service: Order
Service --> Controller: OrderResponse
```

## 클래스 다이어그램

```
┌─────────────────────┐
│   OrderController   │
└──────────┬──────────┘
           │ 의존
           ↓
┌─────────────────────┐
│   OrderService      │←─────────────────┐
│                     │                  │
│ + createOrder()     │                  │
│ + cancelOrder()     │ 모든 비즈니스      │
│ + getOrder()        │ 로직 포함         │
└──────────┬──────────┘                  │
           │ 의존                         │
           ↓                             │
┌──────────────────────────────────────┐ │
│        Repository Layer              │ │
├──────────────────────────────────────┤ │
│ - OrderRepository                    │ │
│ - ProductRepository                  │ │
│ - CustomerRepository                 │ │
└──────────┬───────────────────────────┘ │
           │ 접근                         │
           ↓                             │
┌──────────────────────────────────────┐ │
│         Entity Layer                 │ │
├──────────────────────────────────────┤ │
│ Order (빈약한 도메인)                  │ │
│ - id, customerId, status             │ │
│ - totalAmount, orderItems            │ │
│ + getter/setter만 존재                │◄┘
│                                      │
│ OrderItem, Product, Customer         │
│ (모두 데이터만 가짐)                   │
└──────────────────────────────────────┘
```

## 장점
1. **단순하고 직관적**: 코드의 흐름을 위에서 아래로 쉽게 따라갈 수 있음
2. **빠른 개발**: 복잡한 설계 없이 신속하게 기능 구현 가능
3. **낮은 진입 장벽**: 초보 개발자도 쉽게 이해하고 작성 가능
4. **작은 프로젝트에 적합**: CRUD 중심의 간단한 애플리케이션에 효과적

## 단점
1. **중복 코드 발생**: 비슷한 비즈니스 로직이 여러 메서드에 반복됨
2. **낮은 재사용성**: 비즈니스 규칙이 서비스 메서드에 흩어져 있어 재사용 어려움
3. **테스트 어려움**: 하나의 메서드에 많은 로직이 있어 단위 테스트가 복잡함
4. **확장성 제한**: 비즈니스 로직이 복잡해질수록 유지보수가 어려워짐
5. **객체지향 원칙 위배**: 데이터와 행위가 분리되어 캡슐화가 깨짐

## 적합한 사용 사례
- **단순한 CRUD 애플리케이션**: 복잡한 비즈니스 규칙이 없는 경우
- **프로토타입 개발**: 빠른 검증이 필요한 경우
- **소규모 프로젝트**: 비즈니스 로직이 단순하고 변경이 적은 경우
- **데이터 중심 시스템**: 비즈니스 규칙보다 데이터 처리가 중요한 경우

## 트랜잭션 스크립트 vs 도메인 모델 선택 기준
- 비즈니스 규칙이 **단순하고 변경이 적다** → 트랜잭션 스크립트
- 비즈니스 규칙이 **복잡하고 자주 변경된다** → 도메인 모델
- 프로젝트 규모가 **작고 팀이 작다** → 트랜잭션 스크립트
- 프로젝트 규모가 **크고 장기 유지보수가 필요하다** → 도메인 모델
