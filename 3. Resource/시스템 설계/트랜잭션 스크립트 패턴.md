# 트랜잭션 스크립트 패턴 (Transaction Script Pattern)
각 비즈니스 트랜잭션을 하나의 메서드로 구현하는 패턴  
서비스 계층에서 절차적으로 비즈니스 로직을 구현하며, 도메인 객체는 주로 데이터 전달 용도로만 사용

## 1. 특징
- 절차적 프로그래밍: 비즈니스 로직이 서비스 레이어의 메서드에 순차적으로 작성됨
- 빈약한 도메인 모델: Entity는 getter/setter만 가진 데이터 객체 (Anemic Domain Model)
- 단순한 구조: 이해하기 쉽고 작은 프로젝트에 적합
- 낮은 재사용성: 비즈니스 로직이 분산되어 있어 재사용이 어려움

### 1.1. 장점
- 단순하고 직관적: 코드의 흐름을 위에서 아래로 쉽게 따라갈 수 있음
- 빠른 개발: 복잡한 설계 없이 신속하게 기능 구현 가능
- 낮은 진입 장벽: 쉽게 이해하고 작성 가능
- 작은 프로젝트에 적합: CRUD 중심의 간단한 애플리케이션에 효과적

### 1.2. 단점
- 중복 코드 발생: 비슷한 비즈니스 로직이 여러 메서드에 반복됨
- 낮은 재사용성: 비즈니스 규칙이 서비스 메서드에 흩어져 있어 재사용 어려움
- 테스트 어려움: 하나의 메서드에 많은 로직이 있어 단위 테스트가 복잡함
- 확장성 제한: 비즈니스 로직이 복잡해질수록 유지보수가 어려워짐
- 객체지향 원칙 위배: 데이터와 행위가 분리되어 캡슐화가 깨짐

### 1.3. 적합한 사용 사례
- 단순한 CRUD 애플리케이션: 복잡한 비즈니스 규칙이 없는 경우
- 프로토타입 개발: 빠른 검증이 필요한 경우
- 소규모 프로젝트: 비즈니스 로직이 단순하고 변경이 적은 경우
- 데이터 중심 시스템: 비즈니스 규칙보다 데이터 처리가 중요한 경우


## 2. 패키지 구조
```
src/main/java/com/example/order/
│
├── controller/
│   └── OrderController.java          # API 엔드포인트
│
├── service/
│   └── OrderService.java              # 비즈니스 로직 (트랜잭션 스크립트)
│
├── repository/
│   ├── OrderRepository.java           # 주문 데이터 접근
│   ├── ProductRepository.java         # 상품 데이터 접근
│   └── CustomerRepository.java        # 고객 데이터 접근
│
├── entity/
│   ├── Order.java                     # 주문 엔티티 (데이터만)
│   ├── OrderItem.java                 # 주문 항목 엔티티
│   ├── Product.java                   # 상품 엔티티
│   └── Customer.java                  # 고객 엔티티
│
└── dto/
    ├── CreateOrderRequest.java        # 주문 생성 요청 DTO
    └── OrderResponse.java             # 주문 응답 DTO
```

## 3. 코드 예시
### Entity (빈약한 도메인 모델)
```java
// Order.java - 비즈니스 로직 없이 데이터만 저장
@Entity
@Table(name = "orders")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private Long customerId;
    private LocalDateTime orderDate;
    private String status;
    private BigDecimal totalAmount;
    
    @OneToMany(cascade = CascadeType.ALL)
    private List<OrderItem> orderItems = new ArrayList<>();
    
    // getter, setter만 존재
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public Long getCustomerId() { return customerId; }
    public void setCustomerId(Long customerId) { this.customerId = customerId; }
    // ... 나머지 getter/setter
}
```

```java
// OrderItem.java
@Entity
public class OrderItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private Long productId;
    private Integer quantity;
    private BigDecimal price;
    
    // getter, setter만 존재
}
```

### Service (모든 비즈니스 로직 포함)
```java
// OrderService.java - 모든 비즈니스 로직이 여기에 집중됨
@Service
@RequiredArgsConstructor
public class OrderService {
    
    private final OrderRepository orderRepository;
    private final ProductRepository productRepository;
    private final CustomerRepository customerRepository;
    
    @Transactional
    public OrderResponse createOrder(CreateOrderRequest request) {
        // 1. 고객 검증
        Customer customer = customerRepository.findById(request.getCustomerId())
            .orElseThrow(() -> new IllegalArgumentException("고객을 찾을 수 없습니다."));
        
        if (customer.getStatus().equals("SUSPENDED")) {
            throw new IllegalStateException("정지된 고객은 주문할 수 없습니다.");
        }
        
        // 2. 주문 생성
        Order order = new Order();
        order.setCustomerId(customer.getId());
        order.setOrderDate(LocalDateTime.now());
        order.setStatus("PENDING");
        
        // 3. 주문 항목 처리
        BigDecimal totalAmount = BigDecimal.ZERO;
        
        for (OrderItemRequest itemRequest : request.getItems()) {
            // 3-1. 상품 조회 및 검증
            Product product = productRepository.findById(itemRequest.getProductId())
                .orElseThrow(() -> new IllegalArgumentException("상품을 찾을 수 없습니다."));
            
            // 3-2. 재고 확인
            if (product.getStock() < itemRequest.getQuantity()) {
                throw new IllegalStateException("재고가 부족합니다: " + product.getName());
            }
            
            // 3-3. 주문 항목 생성
            OrderItem orderItem = new OrderItem();
            orderItem.setProductId(product.getId());
            orderItem.setQuantity(itemRequest.getQuantity());
            orderItem.setPrice(product.getPrice());
            
            order.getOrderItems().add(orderItem);
            
            // 3-4. 재고 차감
            product.setStock(product.getStock() - itemRequest.getQuantity());
            productRepository.save(product);
            
            // 3-5. 금액 계산
            BigDecimal itemTotal = product.getPrice()
                .multiply(BigDecimal.valueOf(itemRequest.getQuantity()));
            totalAmount = totalAmount.add(itemTotal);
        }
        
        // 4. 할인 적용 (VIP 고객 10% 할인)
        if (customer.getGrade().equals("VIP")) {
            totalAmount = totalAmount.multiply(BigDecimal.valueOf(0.9));
        }
        
        // 5. 최소 주문 금액 검증
        if (totalAmount.compareTo(BigDecimal.valueOf(10000)) < 0) {
            throw new IllegalStateException("최소 주문 금액은 10,000원입니다.");
        }
        
        // 6. 주문 저장
        order.setTotalAmount(totalAmount);
        Order savedOrder = orderRepository.save(order);
        
        // 7. 응답 생성
        return new OrderResponse(savedOrder);
    }
    
    @Transactional
    public void cancelOrder(Long orderId) {
        // 1. 주문 조회
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new IllegalArgumentException("주문을 찾을 수 없습니다."));
        
        // 2. 취소 가능 상태 확인
        if (!order.getStatus().equals("PENDING")) {
            throw new IllegalStateException("취소할 수 없는 주문 상태입니다.");
        }
        
        // 3. 재고 복구
        for (OrderItem item : order.getOrderItems()) {
            Product product = productRepository.findById(item.getProductId())
                .orElseThrow(() -> new IllegalArgumentException("상품을 찾을 수 없습니다."));
            
            product.setStock(product.getStock() + item.getQuantity());
            productRepository.save(product);
        }
        
        // 4. 주문 상태 변경
        order.setStatus("CANCELLED");
        orderRepository.save(order);
    }
}
```


